# 要件定義書: rubi

**プロジェクト名:** rubi (Markdown Terminology Ruby Generator)
**バージョン:** 1.0.0
**作成日:** 2025/12/04
**ステータス:** 確定

---

## 1. プロジェクト概要

### 1.1. 目的
技術系ブログやドキュメント（Markdown形式）において、読み方が困難な専門用語に対し、HTMLのルビタグ（`<ruby>`）を効率的かつ安全に付与するツールを提供する。

### 1.2. プロジェクトテーマ
**「会議での『これって〇〇読みであってますか？』という確認コストをゼロにする」**
読み方が曖昧な技術用語にルビを振ることで、コミュニケーションの円滑化と心理的安全性の向上を図る。

### 1.3. コアコンセプト
*   **Safety First:** コードブロックやリンク内への誤変換（誤爆）を技術的に封じる。
*   **Explicit Control:** デフォルトでは「書き手が指定した箇所」のみを変換し、意図しない変更を防ぐ。
*   **Format Preservation:** Markdownの整形（リフォーマット）を行わず、元の文章のインデントや改行を維持する。
*   **Community Driven:** 辞書はPRベースで更新し、CLIによる自動チェックで品質を担保する。

---

## 2. システム構成

### 2.1. 技術スタック
*   **開発言語:** Go (Golang)
*   **配布形式:** シングルバイナリ (Windows / macOS / Linux)
*   **主要ライブラリ:** `github.com/yuin/goldmark` (Markdown Parser)

### 2.2. アーキテクチャ方針
*   **AST解析 + ソースパッチ方式:**
    *   MarkdownをAST（抽象構文木）にパースし、置換対象の「バイト位置（Offset）」のみを特定する。
    *   ファイルの書き換えは、特定した位置に対して直接文字列操作を行うことで、関係ない箇所のフォーマット崩れを防止する。

---

## 3. 機能要件

### 3.1. テキスト処理モード

#### A. マニュアルモード（デフォルト）
ユーザーが明示的にマーキングした箇所のみを辞書に基づいて変換する。

*   **トリガー:** `単語:rubi` (例: `Vite:rubi`)
*   **処理:**
    1.  辞書に「単語」が存在する場合 → `<ruby>単語<rt>読み</rt></ruby>` に置換。
    2.  辞書に存在しない場合 → エラーログを出力し、置換しない（または `:rubi` を削除）。

#### B. スキャンモード（オプション）
ドキュメント全体を走査し、辞書にある単語を自動変換する。

*   **トリガー:** コマンドライン引数 (`--scan`) で有効化。
*   **処理:** 文書内のテキストを辞書と照合し、一致する単語を全てルビ付きに変換する。
*   **制約:** 頻出単語によるノイズを防ぐため、オプションで「初出のみ変換 (`--first-only`)」をサポートする。

### 3.2. 除外スコープ（完全必須）
いかなるモードであっても、以下のコンテキスト内にある文字列は**絶対に変換しない**。

1.  **コードブロック内** (` ```go ... ``` `)
2.  **インラインコード内** (` `code` `)
3.  **リンクのURL部分** (`[text](https://do.not.change/here)`)
4.  **HTMLタグの属性値** (`<img src="...">`)

### 3.3. 辞書管理
ユーザーが管理する外部ファイルを読み込む。

*   **ファイル形式:** YAML
*   **必須フィールド:** 単語(`term`)、読み(`yomi`)
*   **任意フィールド:** 読み方の出典(`ref`)

---

## 4. データ構造定義

### 4.1. 辞書ファイル (dictionary.yaml)
```yaml
terms:
  - term: "Vite"
    yomi: "ヴィート"
    ref: "[https://ja.vitejs.dev/](https://ja.vitejs.dev/)"

  - term: "gRPC"
    yomi: "ジーアールピーシー"
    ref: "[https://grpc.io/](https://grpc.io/)"
```

---

## 5. インターフェース仕様 (CLI)

### 5.1. コマンド形式
```bash
rubi [options] <input_file>
```

### 5.2. オプション一覧

| フラグ | 短縮形 | 説明 | デフォルト |
| :--- | :--- | :--- | :--- |
| `--dictionary` | `-d` | 辞書ファイルのパスを指定 | `./dict.yaml` |
| `--write` | `-w` | 入力ファイルを上書き保存する | `false` (標準出力) |
| `--scan` | `-s` | スキャンモード（自動検索）を有効化 | `false` |
| `--check` | `-c` | 辞書ファイルの構文と重複を検証する（CI用） | `false` |
| `--dry-run` | | ファイルを変更せず、変換対象リストを表示 | `false` |

---

## 6. 実装詳細設計（AST戦略）

### 6.1. 処理フロー
1.  **Load:** 対象ファイルをバイト列として読み込む。
2.  **Parse:** `goldmark` を使用して AST を構築する。
3.  **Walk:** ASTを巡回する。
    *   `KindCodeBlock`, `KindLink` などのノードに入ったら、その子要素の走査をスキップ、またはフラグ管理で無視する。
    *   `KindText` ノードのみを対象にする。
4.  **Analyze:** テキストノードの内容 (Segment) を検証する。
    *   **マニュアルモード:** 正規表現 (`([^ :]+):rubi` 等) でサフィックスを検索。
    *   **スキャンモード:** Aho-Corasick法または単純なループで辞書単語を検索。
5.  **Record:** 見つかった箇所の `StartOffset`, `EndOffset`, `置換後の文字列` を構造体に記録し、リスト化する。
6.  **Patch:** リストを後ろ（ファイル末尾）から順に適用し、元のバイト列を書き換える。
    *   ※後ろから置換することで、前方のオフセットがズレるのを防ぐ。

### 6.2. エラーハンドリング
*   辞書ファイルのパースエラー時は即時終了する。
*   Markdownのパースエラー時は、ファイルを破壊しないよう変更を行わずに終了し、エラーを出力する。

---

## 7. 運用・エコシステム (Dictionary Ecosystem)

### 7.1. 課題
*   辞書のメンテナンスが最大のボトルネックである。
*   管理者一人で全ての技術用語を網羅・更新し続けるのはコストが高い。

### 7.2. 解決策: コミュニティ駆動型辞書

辞書を「オープンソース・データ」として扱い、GitHubの機能を活用して分散的にメンテナンスを行う仕組みを構築します。

#### 1. 運用フロー (GitHub Flow)
*   **Single Source of Truth:** 辞書ファイル (`dict.yaml`) を `rubi` のメインリポジトリ（または専用の `rubi-dict` リポジトリ）で管理する。
*   **Pull Request ベース:** ユーザーは不足している単語や誤りを見つけたら、GitHubのWebエディタ等から手軽にPRを送ることができる。
*   **Issue Template:** 「単語追加リクエスト」用のIssueテンプレートを用意し、Gitに詳しくない人でも要望を出せるようにする。

#### 2. 品質担保 (CI/CD)
人の手によるチェックコストを下げるため、GitHub Actions で以下の検証を自動化します。

*   **Syntax Check:** YAMLとして正しい形式か。
*   **Schema Validation:** 必須フィールド (`term`, `yomi`) があるか、型は正しいか。
*   **Duplicate Check:** 既に登録されている単語 (`term`) が重複していないか。
*   **Sorting:** マージ時のコンフリクトを減らすため、`term` のアルファベット順/五十音順にソートされているかを強制する（または自動整形する）。

#### 3. CLI機能の拡張
ユーザーが常に最新の辞書を利用できるように、CLIに以下の機能を追加します。

*   **`rubi init`**: プロジェクト初期化時に、リポジトリから最新の `dict.yaml` をダウンロードして配置する。
*   **`rubi dict update`**: ローカルの `dict.yaml` を最新のコミュニティ版で上書き（またはマージ）する。

#### 4. ファイル分割（スケーラビリティ）
単語数が増えた場合、1つのファイルでは競合が起きやすいため、ディレクトリ分割を検討します。

```text
dictionary/
  ├── a.yaml
  ├── b.yaml
  ...
  ├── go.yaml    (Go言語関連)
  ├── k8s.yaml   (Kubernetes関連)
  └── ...
```

#### 5. 貢献へのインセンティブ
*   **Contributors List:** READMEに辞書貢献者を自動掲載する。
*   **Ref Field:** `ref`（出典）フィールドに、貢献者が参考にした記事（自身のブログ等）を載せることを許容し、モチベーションにつなげる。
